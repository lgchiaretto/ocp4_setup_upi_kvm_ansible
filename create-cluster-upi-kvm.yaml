- name: Create clusters UPI on KVM
  hosts: localhost
  become_method: sudo

  vars:
    mirror_url: "https://mirror.openshift.com/pub/openshift-v4/x86_64/dependencies/rhcos/"

  tasks:
    - name: Check if ocp version is valid
      ansible.builtin.uri:
        url: "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/{{ ocpversion }}/openshift-client-linux.tar.gz"
        method: HEAD
        status_code: 200
      register: result
      ignore_errors: true

    - name: Fail if ocpversion is not valid
      ansible.builtin.fail:
        msg: "The 'ocpversion' variable is not a valid version!"
      when: result.status != 200

    - name: Get a list of all virtual machines
      ansible.builtin.command: virsh list --all --name
      register: vms
      changed_when: vms.rc == 0
      become: true
      when: destroy_if_exists == "true"

    - name: Filter VMs containing 'clustername' in their names
      ansible.builtin.set_fact:
        allvms: "{{ vms.stdout_lines | select('search', clustername) }}"
      when: destroy_if_exists == "true"

    - name: Destroy all vms
      community.libvirt.virt:
        command: destroy
        force: true
        name: "{{ item }}"
      loop: "{{ allvms }}"
      ignore_errors: true
      become: true
      when: destroy_if_exists == "true"

    - name: Undefine all vms
      community.libvirt.virt:
        command: undefine
        force: true
        name: "{{ item }}"
      loop: "{{ allvms }}"
      ignore_errors: true
      become: true
      when: destroy_if_exists == "true"

    - name: Delete all network files
      ansible.builtin.file:
        path: "{{ item }}"
        state: absent
      register: deletefiles
      with_items:
        - "/etc/NetworkManager/dnsmasq.d/{{ clustername }}.conf"
        - "/etc/dnsmasq.{{ clustername }}.addnhosts"
        - "/{{ clusters_dir }}/{{ clustername }}/"
      become: true
      when: destroy_if_exists == "true"

    - name: Configuring networkmanager to use dnsmasq
      ansible.builtin.copy:
        dest: "/etc/NetworkManager/conf.d/nm-dns.conf"
        content: |
          [main]
          dns=dnsmasq
      register: configdnsmasq
      become: true

    - name: Stop systemd-resolved service
      ansible.builtin.systemd:
        name: systemd-resolved
        state: stopped
        enabled: false
      become: true
      when: ansible_facts['distribution'] == 'Fedora'

    - name: Disable systemd-resolved from starting at boot
      ansible.builtin.systemd:
        name: systemd-resolved
        enabled: false
      become: true
      when: ansible_facts['distribution'] == 'Fedora'

    - name: Remove /etc/resolv.conf
      ansible.builtin.file:
        path: /etc/resolv.conf
        state: absent
      when: ansible_facts['distribution'] == 'Fedora'
      become: true

    - name: Restart Network Manager when configuring dnsmasq
      ansible.builtin.service:
        name: NetworkManager
        state: restarted
      become: true

    - name: Sleeping 5 seconds to wait NetworkManager
      ansible.builtin.pause:
        seconds: 5

    - name: Ensure necessary packages are installed
      ansible.builtin.yum:
        name:
          - qemu-kvm
          - libvirt
          - virt-install
          - virt-manager
          - guestfs-tools
          - python3-pip
          - coreos-installer
        state: present
      become: true

    - name: Ensure 'kubernetes' Python package is installed
      ansible.builtin.pip:
        name: kubernetes
        state: present
        executable: pip

    - name: Ensure libvirtd service is running
      ansible.builtin.service:
        name: libvirtd
        state: started
        enabled: true
      become: true

    - name: Create the OCP version cache directory if it does not exist
      ansible.builtin.file:
        path: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/"
        state: directory
        mode: '0755'
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ lookup('env', 'USER') }}"
      become: true

    - name: Check if the installer file already exists on cache
      ansible.builtin.stat:
        path: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/openshift-install-linux-{{ ocpversion }}.tar.gz"
      register: installfile

    - name: Download installer openshift-install-linux.tar.gz to cache
      ansible.builtin.get_url:
        url: "https://mirror.openshift.com/pub/openshift-v4/clients/ocp/{{ ocpversion }}/openshift-install-linux.tar.gz"
        dest: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/openshift-install-linux-{{ ocpversion }}.tar.gz"
        mode: '0644'
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ lookup('env', 'USER') }}"
      become: true
      when: installfile.stat is defined and not installfile.stat.exists

    - name: Check if rhcos.iso file already exists on cache
      ansible.builtin.stat:
        path: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/rhcos.iso"
      register: rhcosisofile

    - name: Download rhcos iso to cache
      ansible.builtin.get_url:
        url: "https://mirror.openshift.com/pub/openshift-v4/x86_64/dependencies/rhcos/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/latest/rhcos-live.x86_64.iso"
        dest: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/rhcos.iso"
        mode: '0644'
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ lookup('env', 'USER') }}"
      become: true
      when:
        - rhcosisofile.stat is defined
        - not rhcosisofile.stat.exists

    - name: Check if the RHCOS file already exists on cache
      ansible.builtin.stat:
        path: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/rhcos-qemu.x86_64.qcow2"
      register: rhcosfile
      when: sno != "true"

    - name: Check if the initramfs file already exists on cache
      ansible.builtin.stat:
        path: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/initramfs.img"
      register: initramfsfile
      when: sno != "true"

    - name: Check if the rhcos-live-kernel-x86_64 file already exists on cache
      ansible.builtin.stat:
        path: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/vmlinuz"
      register: kernelfile
      when: sno != "true"

    - name: Check if the rhcos-live-rootfs.x86_64.img file already exists on cache
      ansible.builtin.stat:
        path: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/rhcos-live-rootfs.x86_64.img"
      register: rootfsfile
      when: sno != "true"

    - name: Download RHCOS images
      ansible.builtin.get_url:
        url: "{{ mirror_url }}{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/latest/rhcos-qemu.x86_64.qcow2.gz"
        dest: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/rhcos-qemu.x86_64.qcow2.gz"
        mode: "0644"
      when: rhcosfile.stat is defined and not rhcosfile.stat.exists and sno != "true"

    - name: Download rootfs file
      ansible.builtin.get_url:
        url: "{{ mirror_url }}{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/latest/rhcos-live-rootfs.x86_64.img"
        dest: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/rhcos-live-rootfs.x86_64.img"
        mode: "0644"
      when: rootfsfile.stat is defined and not rootfsfile.stat.exists and sno != "true"

    - name: Download initramfs images
      ansible.builtin.get_url:
        url: "{{ mirror_url }}{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/latest/rhcos-live-initramfs.x86_64.img"
        dest: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/initramfs.img"
        mode: "0644"
      when: initramfsfile.stat is defined and not initramfsfile.stat.exists and sno != "true"

    - name: Download rhcos-live-kernel-x86_64 images
      ansible.builtin.get_url:
        url: "{{ mirror_url }}{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/latest/rhcos-live-kernel-x86_64"
        dest: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/vmlinuz"
        mode: "0644"
      when: kernelfile.stat is defined and not kernelfile.stat.exists and sno != "true"

    - name: Create cluster directory
      ansible.builtin.file:
        path: "{{ clusters_dir }}/{{ clustername }}"
        state: "directory"
        mode: "0755"
        owner: "{{ lookup('env', 'USER') }}"
        group: "{{ lookup('env', 'USER') }}"
      become: true

    - name: Create rhcos-install directory directory
      ansible.builtin.file:
        path: "{{ clusters_dir }}/{{ clustername }}/rhcos-install"
        state: "directory"
        mode: "0755"
      when: sno != "true"

    - name: Copy openshift-install.tar.gz to cluster dir
      ansible.builtin.copy:
        remote_src: true
        src: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/openshift-install-linux-{{ ocpversion }}.tar.gz"
        dest: "{{ clusters_dir }}/{{ clustername }}/"
        mode: '0644'

    - name: Untar on openshift-install-linux.tar.gz file
      ansible.builtin.unarchive:
        remote_src: true
        src: "{{ clusters_dir }}/{{ clustername }}/openshift-install-linux-{{ ocpversion }}.tar.gz"
        dest: "{{ clusters_dir }}/{{ clustername }}"

    - name: Copy rhcos.iso to cluster dir to master
      ansible.builtin.copy:
        remote_src: true
        src: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/rhcos.iso"
        dest: "{{ clusters_dir }}/{{ clustername }}/rhcos-master.iso"
        mode: '0644'
      when: sno == "true"

    - name: Copy rhcos.iso to cluster dir to worker
      ansible.builtin.copy:
        remote_src: true
        src: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/rhcos.iso"
        dest: "{{ clusters_dir }}/{{ clustername }}/rhcos-worker.iso"
        mode: '0644'

    - name: Copy install-config.yaml
      ansible.builtin.template:
        src: install-config.yaml-upi.j2
        dest: "{{ clusters_dir }}/{{ clustername }}/install-config.yaml"
        mode: '0644'

    - name: Copy files to rhcos-install directory
      ansible.builtin.copy:
        remote_src: true
        src: "{{ clusters_dir }}/.cache/{{ ocpversion | regex_replace('(\\d+\\.\\d+).*', '\\1') }}/{{ item }}"
        dest: "{{ clusters_dir }}/{{ clustername }}/rhcos-install/"
        mode: '0644'
      with_items:
        - vmlinuz
        - initramfs.img
        - rhcos-qemu.x86_64.qcow2.gz
        - rhcos-live-rootfs.x86_64.img
      when: sno != "true"

    - name: Extract RHCOS image
      ansible.builtin.command: "gunzip -f -d {{ clusters_dir }}/{{ clustername }}/rhcos-install/rhcos-qemu.x86_64.qcow2.gz"
      register: extractdfile
      changed_when: extractdfile.rc == 0
      when: sno != "true"

    - name: Resizing RHCOS image
      ansible.builtin.command: "qemu-img resize {{ clusters_dir }}/{{ clustername }}/rhcos-install/rhcos-qemu.x86_64.qcow2 120G"
      register: resizeqcow2
      changed_when: resizeqcow2.rc == 0
      when: sno != "true"

    - name: Create treeinfo file
      ansible.builtin.template:
        src: treeinfo.j2
        dest: "{{ clusters_dir }}/{{ clustername }}/rhcos-install/.treeinfo"
        mode: '0644'
      when: sno != "true"

    - name: Create tmpws.service file
      ansible.builtin.template:
        src: tmpws.service.j2
        dest: "{{ clusters_dir }}/{{ clustername }}/tmpws.service"
        mode: '0644'
      when: sno != "true"

    - name: Create ssh file
      ansible.builtin.copy:
        remote_src: true
        content: "{{ ssh_rsa }}"
        dest: "{{ clusters_dir }}/{{ clustername }}/id_rsa.pub"
        mode: '0644'
      when: sno != "true"

    - name: Run create single-node-ignition-config files
      ansible.builtin.command: "./openshift-install create single-node-ignition-config"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      register: install
      changed_when: true
      when: sno == "true"

    - name: Run create ignition files
      ansible.builtin.command: "./openshift-install create ignition-configs"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      register: install
      changed_when: true
      when: sno != "true"

    - name: Add bootstrap.ign to rhcos-master.iso
      ansible.builtin.command: "coreos-installer iso ignition embed -fi bootstrap-in-place-for-live-iso.ign rhcos-master.iso"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      register: rhcosmaster
      changed_when: true
      when: sno == "true"

    - name: Add worker.ign to rhcos-worker.iso
      ansible.builtin.command: "coreos-installer iso ignition embed -fi worker.ign rhcos-worker.iso"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      register: rhcosworker
      changed_when: true

# TODO: Fix ssh-insoect
#  copy haproxy.cfg to LB
    - name: Customize LB for OpenShift nodes (could take long time)
      ansible.builtin.command: virt-builder fedora-40 --format qcow2 --cache {{ clusters_dir }}/.cache/ --size 10G -o "lb.qcow2" \
                              --firstboot-command "nmcli con mod 'Wired connection 1' connection.id enp1s0" \
                              --firstboot-command "sed -i 's/SELINUX=enforcing/SELINUX=disabled/' /etc/selinux/config" \
                              --firstboot-command "systemctl disable firewalld" \
                              --firstboot-command "setenforce 0" \
                              --firstboot-command "reboot" \
                              --ssh-inject root:file:{{ clusters_dir }}/{{ clustername }}/id_rsa.pub --selinux-relabel \
                              --copy-in bootstrap.ign:/opt/ --copy-in master.ign:/opt/ --copy-in worker.ign:/opt/ \
                              --copy-in tmpws.service:/etc/systemd/system/ \
                              --hostname "lb-{{ clustername }}.{{ basedomain }}" \
                              --install haproxy \
                              --copy-in rhcos-install/rhcos-live-rootfs.x86_64.img:/opt/ \
                              --copy-in rhcos-install/initramfs.img:/opt/ \
                              --copy-in rhcos-install/vmlinuz:/opt/ \
                              --copy-in rhcos-install/.treeinfo:/opt/ \
                              --run-command "systemctl daemon-reload" \
                              --run-command "systemctl enable tmpws.service" \
                              --run-command "systemctl enable haproxy.service" \
                              --root-password password:"{{ htpasswd_pass }}"
      register: customizelb
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      changed_when: customizelb.rc == 0
      when: sno != "true"

    - name: Define and start LB
      ansible.builtin.command: virt-install --import --name {{ clustername }}-lb --disk "lb.qcow2" \
                              --memory 1024 --cpu host --vcpus 4 --os-variant rhel9-unknown --network network={{ kvmnetwork }},model=virtio \
                              --noautoconsole --autostart
      register: definelb
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      changed_when: definelb.rc == 0
      when: sno != "true"

    - name: Wait for lb to get mac address
      ansible.builtin.shell: "virsh dumpxml {{ clustername }}-lb | grep 'mac address' | sed \"s/.*mac address='\\([^']*\\)'.*/\\1/\""
      register: lb_info
      until: lb_info is defined and lb_info.stdout != ""
      retries: "180"
      delay: "1"
      become: true
      changed_when: true
      when: sno != "true"

    - name: Wait for the lb VM to get an IP address
      ansible.builtin.shell: "virsh domifaddr {{ clustername }}-lb | grep ipv4 | awk '{print $4}' | cut -d'/' -f1"
      retries: "180"
      delay: "3"
      until: lbvip.stdout is defined and lbvip.stdout != ""
      register: lbvip
      become: true
      changed_when: true
      when: sno != "true"

    - name: Create virtual machines disks when SNO
      ansible.builtin.command: "qemu-img create -f qcow2 {{ clustername }}-master-0.qcow2 120G"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      register: qcow2master
      changed_when: true
      when: sno == "true"

    - name: Create virtual machines disks when 3 node cluster
      ansible.builtin.copy:
        remote_src: true
        src: "{{ clusters_dir }}/{{ clustername }}/rhcos-install/rhcos-qemu.x86_64.qcow2"
        dest: "{{ clusters_dir }}/{{ clustername }}/{{ item }}.qcow2"
      with_items:
        - "bootstrap"
        - "master-0"
        - "master-1"
        - "master-2"
      when: sno != "true"

    - name: Create worker disks
      ansible.builtin.command: "qemu-img create -f qcow2 {{ clustername }}-worker-{{ item | int + 1 }}.qcow2 120G"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      with_sequence: count={{ n_worker }} start=0
      changed_when: true
      when: n_worker != 0

    - name: Define bootstrap
      ansible.builtin.command: virt-install --name {{ clustername }}-bootstrap \
            --disk {{ clusters_dir }}/{{ clustername }}/bootstrap.qcow2,bus=virtio,size=120 \
            --ram "16000" --cpu host --vcpus "8" --os-variant rhel9-unknown --pxe --network network={{ kvmnetwork }},model=virtio \
            --location rhcos-install/ --noautoconsole \
            --extra-args 'nomodeset rd.neednet=1 coreos.inst=yes coreos.inst.install_dev=vda \
            coreos.live.rootfs_url=http://{{ lbvip.stdout_lines | first }}:1234/rhcos-live-rootfs.x86_64.img \
            coreos.inst.ignition_url=http://{{ lbvip.stdout_lines | first }}:1234/bootstrap.ign'
      register: bootstrapnodes
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      changed_when: bootstrapnodes.rc == 0
      when: sno != "true"

    - name: Wait for the bootstrap VM to get an IP address
      ansible.builtin.shell: "virsh domifaddr {{ clustername }}-bootstrap | grep ipv4 | awk '{print $4}' | cut -d'/' -f1"
      retries: "180"
      delay: "3"
      until: bootstrapip.stdout is defined and bootstrapip.stdout != ""
      register: bootstrapip
      become: true
      changed_when: true
      when: sno != "true"

    - name: Create cluster network conf on dnsmasq when not SNO
      ansible.builtin.template:
        src: "cluster-network.conf.j2"
        dest: "/etc/NetworkManager/dnsmasq.d/{{ clustername }}.conf"
        mode: '0644'
        selevel: s0
        serole: object_r
        setype: dnsmasq_etc_t
        seuser: system_u
      register: dnsmasqsno
      become: true
      when: sno != "true"

    - name: Create addnhosts file when not SNO
      ansible.builtin.template:
        src: "dnsmasq.openshift.addnhosts-bootstrap.j2"
        dest: "/etc/dnsmasq.{{ clustername }}.addnhosts"
        mode: '0644'
      register: addnhosts
      become: true
      when: sno != "true"

    - name: Restart Network Manager when configuring dnsmasq when not SNO
      ansible.builtin.service:
        name: NetworkManager
        state: restarted
      become: true
      when: sno != "true" and dnsmasqsno.changed

    - name: Restart libvirt when configuring dnsmasq when not SNO
      ansible.builtin.service:
        name: libvirtd
        state: restarted
      become: true
      when: sno != "true" and dnsmasqsno.changed

    - name: Define KVM VMs when SNO
      ansible.builtin.command: virt-install --import --name {{ clustername }}-master-0   \
            --disk {{ clusters_dir }}/{{ clustername }}/{{ clustername }}-master-0.qcow2,bus=virtio,size=120 \
            --disk {{ clusters_dir }}/{{ clustername }}/rhcos-master.iso,device=cdrom \
            --boot hd,cdrom --check path_in_use=off --noreboot --noautoconsole \
            --ram "{{ master_mem }}" --cpu host --vcpus "{{ master_cpu }}" --os-variant rhel9-unknown --network network={{ kvmnetwork }},model=virtio
      register: createnodes
      become: true
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      changed_when: createnodes.rc == 0
      when: sno == "true"

    - name: Starting virtual machines when SNO
      ansible.builtin.command: "virsh start {{ clustername }}-{{ item }}"
      register: startsnovms
      changed_when: startsnovms.rc == 0
      become: true
      with_items:
        - "master-0"
      when: sno == "true"

    - name: Define KVM masters on 3 node cluster
      ansible.builtin.command: virt-install --name {{ clustername }}-{{ item }} \
            --disk {{ clusters_dir }}/{{ clustername }}/{{ item}}.qcow2,bus=virtio,size=120 \
            --ram "{{ master_mem }}" --cpu host --vcpus "{{ master_cpu }}" --os-variant rhel9-unknown --pxe --network network={{ kvmnetwork }},model=virtio \
            --location rhcos-install/ --noautoconsole \
            --extra-args 'nomodeset rd.neednet=1 coreos.inst=yes coreos.inst.install_dev=vda \
            coreos.live.rootfs_url=http://{{ lbvip.stdout_lines | first }}:1234/rhcos-live-rootfs.x86_64.img \
            coreos.inst.ignition_url=http://{{ lbvip.stdout_lines | first }}:1234/master.ign'
      register: createnodes
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      changed_when: createnodes.rc == 0
      with_items:
        - "master-0"
        - "master-1"
        - "master-2"
      when: sno == "false"

    - name: Wait for master0 to get mac address when SNO
      ansible.builtin.shell: "virsh dumpxml {{ clustername }}-master-0 | grep 'mac address' | sed \"s/.*mac address='\\([^']*\\)'.*/\\1/\""
      register: master0infosno
      until: master0infosno is defined and master0infosno.stdout != ""
      retries: "180"
      delay: "1"
      become: true
      changed_when: true
      when: sno == "true"

    - name: Wait for master0 to get mac address when not SNO
      ansible.builtin.shell: "virsh dumpxml {{ clustername }}-master-0 | grep 'mac address' | sed \"s/.*mac address='\\([^']*\\)'.*/\\1/\""
      register: master0info
      until: master0info is defined and master0info.stdout != ""
      retries: "180"
      delay: "1"
      become: true
      changed_when: true
      when: sno != "true"


    - name: Wait for master1 to get mac address
      ansible.builtin.shell: "virsh dumpxml {{ clustername }}-master-1 | grep 'mac address' | sed \"s/.*mac address='\\([^']*\\)'.*/\\1/\""
      register: master1info
      until: master1info is defined and master1info.stdout != ""
      retries: "180"
      delay: "1"
      become: true
      changed_when: true
      when: sno != "true"

    - name: Wait for master2 to get mac address
      ansible.builtin.shell: "virsh dumpxml {{ clustername }}-master-2 | grep 'mac address' | sed \"s/.*mac address='\\([^']*\\)'.*/\\1/\""
      register: master2info
      until: master2info is defined and master2info.stdout != ""
      retries: "180"
      delay: "1"
      become: true
      changed_when: true
      when: sno != "true"

    - name: Wait for the master-0 VM to get an IP address
      ansible.builtin.shell: "virsh domifaddr {{ clustername }}-master-0 | grep ipv4 | awk '{print $4}' | cut -d'/' -f1"
      retries: "180"
      delay: "3"
      until: master0ip.stdout is defined and master0ip.stdout != ""
      register: master0ip
      become: true
      changed_when: true

    - name: Wait for the master-1 VM to get an IP address
      ansible.builtin.shell: "virsh domifaddr {{ clustername }}-master-1 | grep ipv4 | awk '{print $4}' | cut -d'/' -f1"
      retries: "180"
      delay: "3"
      until: master1ip.stdout is defined and master1ip.stdout != ""
      register: master1ip
      become: true
      changed_when: true
      when: sno != "true"

    - name: Wait for the master-2 VM to get an IP address
      ansible.builtin.shell: "virsh domifaddr {{ clustername }}-master-2 | grep ipv4 | awk '{print $4}' | cut -d'/' -f1"
      retries: "180"
      delay: "3"
      until: master2ip.stdout is defined and master2ip.stdout != ""
      register: master2ip
      become: true
      changed_when: true
      when: sno != "true"

    - name: Create cluster network conf on dnsmasq when SNO
      ansible.builtin.template:
        src: "cluster-network.conf-sno.j2"
        dest: "/etc/NetworkManager/dnsmasq.d/{{ clustername }}.conf"
        mode: '0644'
        selevel: s0
        serole: object_r
        setype: dnsmasq_etc_t
        seuser: system_u
      register: dnsmasq
      become: true
      when: sno == "true"

    - name: Create cluster network conf on dnsmasq when not SNO
      ansible.builtin.template:
        src: "cluster-network.conf-sno.j2"
        dest: "/etc/NetworkManager/dnsmasq.d/{{ clustername }}.conf"
        mode: '0644'
        selevel: s0
        serole: object_r
        setype: dnsmasq_etc_t
        seuser: system_u
      register: dnsmasq
      become: true
      when: sno != "true"

    - name: Create addnhosts file when not SNO
      ansible.builtin.template:
        src: "dnsmasq.openshift.addnhosts.j2"
        dest: "/etc/dnsmasq.{{ clustername }}.addnhosts"
        mode: '0644'
      register: addnhosts
      become: true
      when: sno != "true"

    - name: Create addnhosts file when SNO
      ansible.builtin.template:
        src: "dnsmasq.openshift.addnhosts-sno.j2"
        dest: "/etc/dnsmasq.{{ clustername }}.addnhosts"
        mode: '0644'
      register: addnhosts
      become: true
      when: sno == "true"

    - name: Restart Network Manager when configuring dnsmasq
      ansible.builtin.service:
        name: NetworkManager
        state: restarted
      when: dnsmasq.changed
      become: true

    - name: Restart libvirt when configuring dnsmasq
      ansible.builtin.service:
        name: libvirtd
        state: restarted
      when: dnsmasq.changed
      become: true

    - name: Adding master mac on DHCP when SNO
      community.libvirt.virt_net:
        name: "{{ kvmnetwork }}"
        command: modify
        xml: "<host mac='{{ master0infosno.stdout }}' ip='{{ master0ip.stdout_lines | first }}'/>"
      register: master0infosno
      become: true
      when: sno == "true"

    - name: Adding lb and masters mac on DHCP when 3-node
      community.libvirt.virt_net:
        name: "{{ kvmnetwork }}"
        command: modify
        xml: "<host mac='{{ item.mac }}' ip='{{ item.ip }}'/>"
      register: allmacsinfo
      become: true
      with_items:
        - { mac: "{{ lb_info.stdout }}", ip: "{{ lbvip.stdout_lines | first }}" }
        - { mac: "{{ master0info.stdout }}", ip: "{{ master0ip.stdout_lines | first }}" }
        - { mac: "{{ master1info.stdout }}", ip: "{{ master1ip.stdout_lines | first }}" }
        - { mac: "{{ master2info.stdout }}", ip: "{{ master2ip.stdout_lines | first }}" }
      when: sno != "true"
      ignore_errors: true

    - name: Copy haproxy.cfg to lb
      ansible.builtin.template:
        src: "haproxy.cfg-kvm.j2"
        dest: "/etc/haproxy/haproxy.cfg"
        mode: "0644"
      delegate_to: "{{ lbvip.stdout_lines | first }}"
      remote_user: "root"
      when: sno != "true"

    - name: Restart haproxy on LB
      ansible.builtin.systemd:
        name: haproxy
        state: restarted
        enabled: false
      delegate_to: "{{ lbvip.stdout_lines | first }}"
      remote_user: "root"
      when: sno != "true"

    - name: Waiting for RHCOS Installation to finish on bootstrap
      ansible.builtin.shell: "virsh list --name |  { grep -E '{{ clustername }}-master|{{ clustername }}-worker|{{ clustername }}-bootstrap' || true; }"
      retries: 600
      delay: 5
      register: vms
      until: vms.stdout == ""
      when: sno != "true"

    - name: Starting virtual machines when 3-node cluster
      ansible.builtin.command: "virsh start {{ clustername }}-{{ item }}"
      register: startsnovms
      changed_when: startsnovms.rc == 0
      become: true
      with_items:
        - "bootstrap"
        - "master-0"
        - "master-1"
        - "master-2"
      when: sno != "true"

    - name: Define KVM Workers
      ansible.builtin.command: virt-install  --import --name {{ clustername }}-worker-{{ item }}   \
            --disk {{ clusters_dir }}/{{ clustername }}/{{ clustername }}-worker-{{ item }}.qcow2,bus=virtio,size=120 \
            --disk {{ clusters_dir }}/{{ clustername }}/rhcos-worker.iso,device=cdrom \
            --boot hd,cdrom --check path_in_use=off --noautoconsole \
            --ram {{ worker_mem }} --cpu host --vcpus {{ worker_cpu }} --os-variant rhel9-unknown --network network={{ kvmnetwork }},model=virtio \
      register: createworkers
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      changed_when: createworkers.rc == 0
      with_sequence: count={{ n_worker }}
      when: n_worker != 0
      become: true

    - name: Wait for the worker VM's to get an IP address
      ansible.builtin.shell: "virsh domifaddr {{ clustername }}-worker-{{ item }} | grep ipv4 | awk '{print $4}' | cut -d'/' -f1"
      retries: "180"
      delay: "3"
      until: workerip.stdout is defined and workerip.stdout != ""
      register: workerip
      with_sequence: count={{ n_worker }}
      when: n_worker != 0
      become: true

    - name: Get a list of all virtual machines
      ansible.builtin.command: virsh list --all --name
      register: vms
      changed_when: vms.rc == 0
      become: true

    #  TODO: fix
    - name: Filter VMs containing 'worker' in their names
      ansible.builtin.set_fact:
        worker_vms: "{{ vms.stdout_lines | select('search', 'worker') }}"
      when: n_worker != 0
      become: true

    - name: Gather MAC addresses of VMs
      ansible.builtin.command: virsh domifaddr {{ item }}
      loop: "{{ worker_vms }}"
      register: vm_interfaces
      changed_when: vm_interfaces.rc == 0
      when: n_worker != 0
      become: true

    - name: Extract MAC addresses from interface information
      ansible.builtin.set_fact:
        mac_addresses: "{{ mac_addresses | default([]) + [item.stdout | regex_findall('([\\w:]{17})')] }}"
        worker_ips: "{{ worker_ips | default([]) + [item.stdout | regex_findall('\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}')] }}"
      loop: "{{ vm_interfaces.results }}"
      when: n_worker != 0
      become: true

    - name: Adding worker mac on DHCP
      community.libvirt.virt_net:
        name: "{{ kvmnetwork }}"
        command: modify
        xml: "<host mac='{{ mac_addresses[item | int - 1] | first }}' ip='{{ worker_ips[item | int - 1] | first }}'/>"
      register: worker_info
      with_sequence: count={{ n_worker }}
      when: n_worker != 0
      become: true

    - name: Adding worker names on dhcp
      ansible.builtin.lineinfile:
        path: "/etc/dnsmasq.{{ clustername }}.addnhosts"
        line: '{{ worker_ips[item | int - 1] | first }} {{ clustername }}-worker-{{ item }}.{{ basedomain }}'
        state: present
      register: dhcpname
      with_sequence: count={{ n_worker }}
      when: n_worker != 0
      become: true

    - name: Restart Network Manager when configuring dnsmasq
      ansible.builtin.service:
        name: NetworkManager
        state: restarted
      become: true

    - name: Restart libvirt when configuring dnsmasq
      ansible.builtin.service:
        name: libvirtd
        state: restarted
      become: true

    - name: Add StrictHostKeyChecking option to SSH config
      ansible.builtin.lineinfile:
        path: "{{ lookup('env', 'HOME') }}/.ssh/config"
        create: true
        mode: '0600'
        line: "StrictHostKeyChecking no"
        state: present
        insertafter: EOF
        owner: "{{ ansible_facts['user_id'] }}"
        group: "{{ ansible_facts['user_id'] }}"

    - name: Sleeping for 20 minutes before to check if cluster has been installed
      ansible.builtin.pause:
        minutes: 20

    - name: Wait for SSH to be available on the target node
      ansible.builtin.wait_for:
        host: "{{ worker_ips[item | int - 1] | first }}"
        port: 22
        timeout: 3600
        state: started
        sleep: 10
      with_sequence: count={{ n_worker }}
      when: n_worker != 0

    - name: Copy worker.ign to worker nodes
      ansible.builtin.copy:
        src: "{{ clusters_dir }}/{{ clustername }}/worker.ign"
        dest: "/var/home/core/worker.ign"
        mode: "0644"
      delegate_to: "{{ worker_ips[item | int - 1] | first }}"
      with_sequence: count={{ n_worker }}
      remote_user: "core"
      when: n_worker != 0

    - name: Execute coreos-installer on worker nodes
      ansible.builtin.shell:
        cmd: "coreos-installer install --ignition-file=/var/home/core/worker.ign /dev/vda"
      delegate_to: "{{ worker_ips[item | int - 1] | first }}"
      with_sequence: count={{ n_worker }}
      remote_user: "core"
      become: true
      when: n_worker != 0

    - name: Rebooting worker nodes
      ansible.builtin.reboot:
        reboot_timeout: 300
      delegate_to: "{{ worker_ips[item | int - 1] | first }}"
      with_sequence: count={{ n_worker }}
      remote_user: "core"
      become: true
      when: n_worker != 0

    - name: Creating CSR Approver manifests
      kubernetes.core.k8s:
        kubeconfig: "{{ clusters_dir }}/{{ clustername }}/auth/kubeconfig"
        state: present
        template: "{{ item }}.yaml.j2"
      loop:
        - csr-approver-ns
        - csr-approver-sa
        - csr-approver-cr
        - csr-approver-crb
        - csr-approver-rb
        - csr-approver-cronjob
      register: result
      until: result is succeeded
      retries: 60
      delay: 10
      failed_when: result is failed or result.failed
      when: n_worker != 0

    - name: Run wait-for bootstrap-complete
      ansible.builtin.command: "./openshift-install wait-for bootstrap-complete"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      async: 3600
      poll: 0
      register: waitbootstrap
      changed_when: true
      when: sno != "true"

    - name: Check if bootstrap vm can be removed
      ansible.builtin.async_status:
        jid: "{{ waitbootstrap.ansible_job_id }}"
      register: job_result
      until: job_result.finished
      delay: 10
      retries: 600
      when: sno != "true"

    - name: Remove bootstrap VM
      community.libvirt.virt:
        name: "{{ clustername }}-bootstrap"
        state: destroyed
      when: sno != "true"

    - name: Undefine bootstrap VM
      community.libvirt.virt:
        name: "{{ clustername }}-bootstrap"
        command: undefine
        force: true
      when: sno != "true"

    - name: Set the number of replicas for the 'default' ingresscontroller to 3
      kubernetes.core.k8s:
        kubeconfig: "{{ clusters_dir }}/{{ clustername }}/auth/kubeconfig"
        api_version: operator.openshift.io/v1
        kind: IngressController
        namespace: openshift-ingress-operator
        name: default
        state: present
        definition:
          spec:
            replicas: 3
      when: sno != "true"     

    - name: Run wait-for install-complete
      ansible.builtin.command: "./openshift-install wait-for install-complete"
      args:
        chdir: "{{ clusters_dir }}/{{ clustername }}"
      async: 3600
      poll: 0
      register: install
      changed_when: true

    - name: Check if the cluster has been installed
      ansible.builtin.async_status:
        jid: "{{ install.ansible_job_id }}"
      register: job_result
      until: job_result.finished
      delay: 10
      retries: 600

    - name: Pause cronjob ocp-csr-approver
      kubernetes.core.k8s:
        kubeconfig: "{{ clusters_dir }}/{{ clustername }}/auth/kubeconfig"
        state: present
        definition:
          apiVersion: batch/v1
          kind: CronJob
          metadata:
            name: "ocp-csr-approver"
            namespace: "ocp-csr-approver"
          spec:
            suspend: true
      when: sno != "true"
